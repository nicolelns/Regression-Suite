#! /usr/bin/python
# -*- coding: utf-8 -*-

import os
import sys
import unittest
import time, datetime
import re
import pickle
import Logger			# Logging module (for test results, outputs results to a .txt or .p file)
import cutSoup     		# BeautifulSoup page scraper collects relevant data from qa
from selenium import selenium   # Update to webdriver

reload(sys)
sys.setdefaultencoding("utf-8")	# Sets encoding

BASEURL = 'http://ec2.qa.nymetro.com/thecut/celebrity/'
BROWSERS = ('chrome', 'firefox', 'safari')	# IE must be run through WebDriver remote (which does not have good window resizing func)
TEST = "Celebrity Splash Page - QA - The Cut"

L = Logger.MainLogger(BASEURL, TEST)

S = cutSoup.Parser(BASEURL)
S.qa_celebrity_splash_lede()

CSS = open('../data/text/qa.celebritysplashlede.css.txt', 'r').readlines()
FEED_DATA = pickle.load(open('../data/pickle/qa.celebritysplashlede.data.p', 'rb'))

feed_keys = FEED_DATA.keys()
feed_values = FEED_DATA.values()

x = 0

"""
This is a test for the Cut Celebrity Splash Pages:
The DATA file is a pickle file generated by vultureSoup.Parser(), customized for this module.
IF ANY CHANGES TO THE MODULE HAPPEN, PLEASE ONLY CHANGE THE .TXT, .P and .JSON FILES IF YOU REALLY KNOW WHAT YOU ARE DOING!
"""	

#########################################################################
#########################################################################
	

class CelebritySplash(unittest.TestCase):

    def setUp(self):

        self.verificationErrors = []
        self.selenium = selenium("localhost", 4444, "*" + BROWSERS[x], BASEURL)
        self.selenium.start()
        print "TESTING www.thecut.com in " + BROWSERS[x]
	
	########################################################################
    
    def test_splash_lede(self):
        
        """
        Preliminary test for the presence of various elements in each article in the Celebrity/Fame feed.
        CSS selectors are in a .txt file, and this test makes sure each element exists on the page before proceeding.
        Failures will fail the whole test.  (No point in continuing if images and links aren't present, right?).
        The other tests are called from this function to avoid repetitive and unnecessary SetUp and TearDown of the browser.
        In addition, the other tests can be commented out and not run - easy to select which tests run.  None are dependent on 
        results from other tests.  Only test_splash_feed needs to be run for the sub-tests to run.
        
        PASSING CONDITIONS:  All elements are present on the page.
        FAILING CONDITIONS:  Any ONE element is not present on the page.
        """
	
        n = 0
        sel = self.selenium
        sel.open(BASEURL)
        sel.wait_for_page_to_load("50000")
        test = "Test A - Presence of elements via CSS"
        print test
        
        # Loops through the data in the CSS file asserting each element is on the page
        
        for each in CSS:

	    c = CSS[n].strip('\n')
            
            try:
                self.failUnless(sel.is_element_present("css=" + c))
                
            except AssertionError, e:
            	print "FAILURE " + c
            	self.verificationErrors.append(str(e))
                L.log(BROWSERS[x], test, "FAIL, ELEMENT NOT FOUND", c, exception=str(e))
            
            else:
                L.log(BROWSERS[x], test, "PASS, ELEMENT FOUND", c)
                
            n += 1
        
        self.b_count_test()		# Verifies that each article has a headline, image and author    	
        self.c_arrow_test()		# Tests to make sure that the arrow buttons and lede 'dots' (circles below the lede) work)
        #self.d_responsive_test()	# Tests the responsive design of the page
        self.e_clicky_test()		# Functional test - clicks on links and images to make sure they load the correct page
            
        ########################################################################
	    
    def b_count_test(self):
    	    
        """
        This test collects the number of images, authors, etc. present on the page at page load.
        This test looks for missing content.  If the number of images, authors, etc. is not equal to the number
        of articles in the lede, the test fails.
        
        PASSING CONDITIONS:  The difference in css_count before clicking the button and after is strictly equal to 
                             the number of articles that appear after clicking the "Show More" button.
        FAILING CONDITIONS:  The difference in css_count is not equal to the number of articles that appear after
        		     clicking the "Show More" button.
        """
    	 
	sel = self.selenium
        test = "Test B - Count Articles, Titles, Headings, Etc."
        print test
        
        headers = sel.get_css_count("css=" + CSS[1])
        images = sel.get_css_count("css=" + CSS[2])
        authors = sel.get_css_count("css=" + CSS[3])
	dots = sel.get_css_count("css=" + CSS[7]) + sel.get_css_count("css=" + CSS[6])	
        
        if ((images < 8) or (dots < 8) or (authors < 8) or (headers < 8)):
            print "Missing articles!"
            L.log(BROWSERS[x], test, "FAIL, MISSING CONTENT", "Images: " + str(images) + " Dots: " + str(dots) + " Authors: " + str(authors) + " Headers: " + str(headers)) 
    
	else:
	    L.log(BROWSERS[x], test, "PASS, OK", "None")
	    
	########################################################################    
   
    def c_arrow_test(self):
    	    
    	"""
    	This test asserts that the arrow buttons and active article dots below the lede work.
    	This test will run even if failing conditions are met for any one article.
    	
    	PASSING CONDITIONS:   
    	FAILING CONDITIONS:  
    	"""
     	     
        l = 0    
        sel = self.selenium
        test = "Test C - Arrow and Lede Marker Button Functionality"
        print test
        sel.refresh()
        sel.wait_for_page_to_load("50000")
        
        nums_right_arrow = (1,2,3,4,5,6,7,0,1)
        nums_left_arrow = (0,7,6,5,4,3,2,1,0)
        img_list = []
        
	for each in feed_values:
	
	    foo = feed_values[l]
	    bar = foo[0]
	    
	    for each in bar:
	    	
                if re.search("4x", bar[0], re.I) and (bar[0] not in img_list):
                    img_list.append(bar[0])
	    
	    l += 1
	  
	for z in range(0,8):
        
            num1 = nums_right_arrow[z]
            #sel.mouse_over("css=" + CSS[0].strip('\n'))
            #time.sleep(10)
            #self.failUnless(sel.is_visible("css=" + CSS[4].strip('\n'))) 
            sel.click("css=" + CSS[4].strip('\n'))
            time.sleep(2)
            
            try:
                sel.is_visible("//img[@src='" + img_list[num1] + "']")	# Get correct image
            
    	    except Exception, e:
    	    	L.log(BROWSERS[x], test, "FAIL, INCORRECT IMAGE DISPLAYS AFTER CLICKING ARROW", img_list[num1], exception=str(e))
        
	    else:
	        L.log(BROWSERS[x], "Test C - Functionality", "PASS, CORRECT IMAGE DISPLAYS AFTER CLICKING ARROW", img_list[num1])
	    	   
	    z += 1
	
	z = 0
	
	for z in range(0,8):
        
            num2 = nums_left_arrow[z]
            #sel.mouse_over("css=" + CSS[0].strip('\n'))
            #time.sleep(10)
            #self.failUnless(sel.is_visible("css=" + CSS[4].strip('\n'))) 
            sel.click("css=" + CSS[4].strip('\n'))
            time.sleep(2)
            
            try:
                sel.is_visible("//img[@src='" + img_list[num2] + "']")	# Get correct image
            
    	    except Exception, e:
    	    	L.log(BROWSERS[x], test, "FAIL, INCORRECT IMAGE DISPLAYS AFTER CLICKING ARROW", img_list[num2], exception=str(e))
        
	    else:
	        L.log(BROWSERS[x], "Test C - Functionality", "PASS, CORRECT IMAGE DISPLAYS AFTER CLICKING ARROW", img_list[num2])
	   
	    z += 1
	    
        ########################################################################
        
    def d_responsive_test(self):
    	    
    	"""
    	This test resizes the browser window to test the feed for responsive design functionality.
    	The browser is first set to full screen for desktop, resized for tablet, then resized for mobile.
    	Image height/width, header position and link position (for the article header) are retrieved.
    	Element sizes and positions are then compared to ensure that they change with window sizes accordingly.
    	This test will run even if failing conditions are met for any one article.
    	
    	PASSING CONDITIONS:  For images: if desktop element size > tablet element size > mobile element size
    			     For excerpts/titles: if elements do not move further left on the page.
    	                     (elements should get smaller/move to the left as the window size shrinks)
    	FAILING CONDITIONS:  Elements do not shrink/move left when the browser is resized.
    	"""
    	   
        sel = self.selenium
        test = "Test D - Responsive Design"
        print test
        m = 0
        
        for each in feed_keys:
        	
            data = feed_values[m]
            img = data[0]
            
            if image is not None:
            	
		for w in range(0,3):
		    	    
		    if w == 0:
		            
		    	try:    
			    sel.window_maximize()
			    desktop_height = sel.get_element_height("//source[@src='" + image[0] + "']")
			    desktop_width = sel.get_element_width("//source[@src='" + image[0] + "']")
			    desktop_header_loc = sel.get_element_position_left("//h2[@class='ledeHeadline']")
			    desktop_author_loc = sel.get_element_position_left("//span[@class='ledeByline']")
			  
		  	except Exception, e:	  
			    print "FAIL", str(e)
			    
		    elif w == 1:
		    	    
		    	try:    
			    sel.get_eval("window.resizeTo(728, 1000);")
			    tablet_height = sel.get_element_height("//source[@src='" + image[2] + "']")
			    tablet_width = width = sel.get_element_width("//source[@src='" + image[2] + "']")
			    tablet_paragraph_loc = sel.get_element_position_left("//h2[@class='ledeHeadline']")
			    tablet_author_loc = sel.get_element_position_left("//span[@class='ledeByline']")
			
			except Exception, e:	  
			    print "FAIL", str(e)
			    
		    elif w == 2:
		    	    
		    	try:    
			    sel.get_eval("window.resizeTo(420, 600);")
			    mobile_height = sel.get_element_height("//img[@src='" + image[1] + "']")
			    mobile_width = sel.get_element_width("//img[@src='" + image[1] + "']")
			    mobile_header_loc = sel.get_element_position_left("//h2[@class='ledeHeadline']")
			    mobile_author_loc = sel.get_element_position_left("//span[@class='ledeByline']")
			    
			except Exception, e:	  
			    print "FAIL", str(e)
			    
		    w += 1
                
            	if ((desktop_height >= tablet_height) and (desktop_height >= mobile_height) and (tablet_height >= mobile_height)):
            	    L.log(BROWSERS[x], test, "PASS, IMAGE RESPONDS TO WINDOW RESIZE", image)
                
            	else:
            	    print "Resize image fails!", image
            	    L.log(BROWSERS[x], test, "FAIL, IMAGE DOES NOT RESPOND TO WINDOW RESIZE", image)
                    
            	if ((desktop_header_loc >= mobile_header_loc) and (tablet_header_loc >= mobile_header_loc)):
                    L.log(BROWSERS[x], test, "PASS, EXCERPT RESPONDS TO WINDOW RESIZE", "Excerpt for " + feed_keys[m])
                
            	else:
            	    print "Resize exceprt fails!", feed_keys[m]
            	    L.log(BROWSERS[x], test, "FAIL, EXCERPT DOES NOT RESPOND TO WINDOW RESIZE", "Excerpt for " + feed_keys[m])
                
            	if ((desktop_author_loc >= mobile_author_loc) and (tablet_author_loc >= mobile_author_loc)):
            	    L.log(BROWSERS[x], test, "PASS, ARTICLE AUTHOR RESPONDS TO WINDOW RESIZE", "Author for " + feed_keys[m])
                
            	else:
            	    L.log(BROWSERS[x], test, "FAIL, ARTICLE AUTHOR DOES NOT RESPOND TO WINDOW RESIZE", "Author for " + feed_keys[m])
            
	    else:
            	print "NO IMAGE for URL " + feed_keys[m]
	        L.log(BROWSERS[x], test, "FAIL, NO IMAGE FOR URL!", feed_keys[m])
	        
	    m += 1
            
        sel.get_eval("window.resizeTo(1200, 1000);")    
            
    	########################################################################

    def e_clicky_test(self):
    	    
        """
        This test makes Selenium do some real work - functionality of links and images is tested.
        All links are clicked on and tested to make sure the page loads, the title does not have "not found" in it, and
        the title is stored in a variable.
        All images are clicked on and tested to make sure the page loads, the title does not have "not found" in it, and
        the title is compared to the previous link's title to make sure the correct article loads (in other words, to make
        sure that the image is associated with the correct article.
        This test will not fail when one error is encountered - the test will continue to check all links and images regardless
        of a failure, unless an exception is thrown that breaks the test itself.
        
        PASSING CONDITIONS:  All pages load, no pages have 404/not found errors, and the link and image direct the user to
        		     the correct page.
        FAILING CONDITIONS:  Any of the links/images do not load or are not on the page, any of the links/images return pages with 404/not found errors,
        		     any of the link/image pairs contain mismatched titles, indicating that either an article link is broken
        		     or a link with an associated image is not correctly paired to the article title.
        """
    	
    	m = 0 
        sel = self.selenium
        test = "Test E - Functional test for urls"
        print test
        
        for each in feed_keys:
		
	    d = feed_keys[m]
	    data_values = feed_values[m]
	    img = data_values[0]
	    c = img[0]
	    
	    try:
                sel.click("//a[@href='" + d + "']")
                sel.wait_for_page_to_load("50000")
                
	    except Exception, e:
		print "FAILURE " + d, " does not load"
		L.log(BROWSERS[x], test, "FAIL, PAGE DOES NOT LOAD", d, exception=str(e))
		
	    else:
	    	try:
	    	    title = sel.get_title()
	    
                except Exception, e:
                    print "FAILURE " + d, " cannot get title"
                    L.log(BROWSERS[x], test, "FAIL, CANNOT GET TITLE", d, exception=str(e))
	    	
		else:
		    if re.search("Not Found", title, re.I):
		    	print "FAILURE " + d, " Page Not Found!"
		        L.log(BROWSERS[x], test, "FAIL, 404 ERROR!", "Page: " + d + " Title: " + title)
	      		
	      	    else:
	    		L.log(BROWSERS[x], test, "PASS, PAGE LOADS", "Page: " + d + " Title: " + title)
		
                sel.go_back()
	        sel.wait_for_page_to_load("50000")
	        
	# Second, make sure each image can be clicked on and that the page loads  
	
	    if c is not None:
	        try:
                    sel.click("//img[@src='" + c + "']")
                    sel.wait_for_page_to_load("50000")
                
	        except Exception, e:
		    print "FAILURE " + c, " does not load"
		    L.log(BROWSERS[x], test, "FAIL, IMAGE DOES NOT LOAD", c, exception=str(e))
		
	        else:
	            try:
	    	        img_title = sel.get_title()
                    except Exception, e:
                    	print "FAILURE " + c, " cannot get title"
                        L.log(BROWSERS[x], test, "FAIL, CANNOT GET TITLE", d, exception=str(e))
	    	
		    else:
		        if re.search("Not Found", img_title, re.I):
		            print "FAILURE " + c, " Page Not Found!"
		            L.log(BROWSERS[x], test, "FAIL, 404 Error!", "Page: " + d + " Title: " + title)
	      		
	      	        elif not re.search(img_title, title, re.I):
	      	            print "FAILURE " + c, " URL associated with image (href, not src) does not match article URL"
	      	            L.log(BROWSERS[x], test, "FAIL, Mismatched titles for image link and permalink", "Page: " + d + " Article Link Title: " + title, "Image Link Title: " + img_title)
	            
	    		else:
	    		    L.log(BROWSERS[x], test, "PASS, ARTICLE TITLE URL MATCHES ASSOCIATED IMAGE URL", c)
		    
 		    sel.go_back()
	            sel.wait_for_page_to_load("50000")
	            
	    else:
	    	print "NO IMAGE for URL " + d
	        L.log(BROWSERS[x], test, "FAIL, NO IMAGE FOR URL!", "URL: " + d)
	        
	    m += 1

        ########################################################################

    def tearDown(self):

        self.selenium.stop()
        self.assertEqual([], self.verificationErrors)

#########################################################################
#########################################################################

for each in BROWSERS:

    suite = unittest.TestLoader().loadTestsFromTestCase(CelebritySplash)
    unittest.TextTestRunner(verbosity=2).run(suite)
    x += 1
L.save()
