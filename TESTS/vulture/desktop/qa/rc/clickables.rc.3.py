#! /usr/bin/python

import unittest
import time, datetime
import re
import pickle
import Logger			# Logging module (for test results, outputs results to a .txt file)
import vultureSoup		# BeautifulSoup page scraper collects relevant data from vulture.com
from selenium import selenium   # Update to WebDriver 

BASEURL = 'http://www.vulture.com'
BROWSERS = ('chrome', 'firefox', 'safari')
TEST = "Clickables Module - Desktop - Vulture Home Page"

L = Logger.MainLogger(BASEURL, TEST)
S = vultureSoup.Parser()

S.clickables()			# Call the relevant BeautifulSoup function (usually same name as test)

CSS = open('../data/text/clickables.css.txt', 'r').readlines()		# CSS Selectors for elements
DATA = pickle.load(open('../data/pickle/clickables.data.p', 'rb')) 	# Dictionary with data
      
keys = DATA.keys()
values = DATA.values()    
      
x = 0

"""
This is a test for Vulture's Clickables module on the home page for desktop (non-mobile).
The DATA file is a pickle file generated by vultureSoup.Parser(), customized for this module.
IF ANY CHANGES TO THE MODULE HAPPEN, PLEASE ONLY CHANGE THE .TXT, .P and .JSON FILES IF YOU REALLY KNOW WHAT YOU ARE DOING!

"""	

#########################################################################
#########################################################################
	

class Clickables(unittest.TestCase):

    def setUp(self):

        self.verificationErrors = []
        self.selenium = selenium("localhost", 4444, "*" + BROWSERS[x], BASEURL + '/')
        self.selenium.start()
	print "TESTING www.vulture.com in " + BROWSERS[x]
	
	########################################################################
    
    def test_clickables(self):

    	"""
        Preliminary test for the presence of various elements in the clickables module.
        CSS selectors are in a .txt file, and this test makes sure each element exists on the page before proceeding.
        Failures will fail the whole test.  (No point in continuing if links aren't present, right?).
        The other tests are called from this function to avoid repetitive and unnecessary SetUp and TearDown of the browser.
        In addition, the other tests can be commented out and not run - easy to select which tests run.  None are dependent on 
        results from other tests.  Only test_splash_feed needs to be run for the sub-tests to run.
        
        PASSING CONDITIONS:  All elements are present on the page.
        FAILING CONDITIONS:  Any ONE element is not present on the page.
        
        """
	
	n = 0
	sel = self.selenium
        sel.open(BASEURL)
        sel.wait_for_page_to_load("50000")
        test = "Test A - Presence of Elements via CSS"
        print test
        
	for each in CSS:

	    c = CSS[n].strip('\n') 
        
            try:
                self.failUnless(sel.is_element_present("css=" + c))
               
            except AssertionError, e:
            	print "FAILURE, ELEMENT NOT FOUND" + c, "Error: " + str(e)
            	self.verificationErrors.append(c + str(e))
                L.log(BROWSERS[x], test, "FAIL, ELEMENT NOT FOUND", c, exception=str(e))
            
            else:
                L.log(BROWSERS[x], test, "PASS, ELEMENT FOUND", c)
                
            n += 1
            
        self.b_link_match_test()
        self.c_link_display_test()
        self.d_link_text_test()
        self.g_logo_test()
            
        ########################################################################
	    	
    def b_link_match_test(self):
    	    
        """
        Verifies that the URL is located as both a permalink and an href link and the URLS are the same
        
        PASSING CONDITIONS:	Each URL will be found as both: <a href='URL'> and <article data-permalink='URL'>
        			The URLS will match
        			
        FAILING CONDITIONS:	URL is not found in both locations
        			URLS do not match
        
        """
    	    
        n = 0
	sel = self.selenium
        test = "Test B - Verify Each URL Has a Permalink and Regular Link"
        print test

	for each in keys:
        	
            data = values[n]	
            entry_type = data[0]
            
            try:
            	self.assertEqual(sel.is_element_present("//a[@href='" + keys[n] + "']"), sel.is_element_present("//article[@data-permalink='" + keys[n] + "']"))
                	
            except AssertionError, e:
            	print "FAILURE, URLS DO NOT MATCH" + keys[n], "Error: " + str(e)
            	self.verificationErrors.append(keys[n] + str(e))
                L.log(BROWSERS[x], test, "FAIL, URLS NOT FOUND/MISMATCHED", keys[n], exception=str(e))
                
            else:
                L.log(BROWSERS[x], test, "PASS, URLS MATCH/FOUND", keys[n])
                
            n += 1
            
        if (len(keys) > 20 or len(keys) < 8):
            print "FAILURE, WRONG NUMBER OF ARTICLES" + str(len(keys))
            self.verificationErrors.append(str(len(keys)))
            L.log(BROWSERS[x], test, "FAIL, WRONG NUMBER OF ARTICLES", str(len(keys)))
            
        else:
            L.log(BROWSERS[x], test, "PASS, URLS MATCH/FOUND", str(len(keys)))
            
        ########################################################################
        
    def c_link_display_test(self):
    	    
    	"""
        Verifies that the URL is displayed on the page
        
        PASSING CONDITIONS:	Greater than 5 entries or fewer than 20 entries are showing
        FAILING CONDITIONS:	Fewer than 5 entries or greater than 20 entries are showing
        
        """
    	    
        n = 0
        count = 0 	# Counter for visible articles
	sel = self.selenium
        test = "Test C - Number of Clickables that Display"
        print test

	for each in keys:
        	
            data = values[n]	
            entry_type = data[0]
            
            try:
                sel.is_visible("//a[@href='" + keys[n] + "']")
           
   	    except Exception, e:
   	        self.verificationErrors.append(keys[n] + str(e))
                L.log(BROWSERS[x], test, "FAIL, URLS NOT SHOWING", keys[n], exception=str(e))
            
            else:
               count += 1
               L.log(BROWSERS[x], test, "PASS, URLS SHOWING", keys[n])
               
            n += 1
            
        if count < 5 or count > 20:
            print "FAILURE, WRONG NUMBER OF ARTICLES" + str(count)
            L.log(BROWSERS[x], test, "FAIL, WRONG NUMBER OF ARTICLES SHOW", str(count))
        
	else:
	    L.log(BROWSERS[x], test, "PASS, CORRECT NUMBER OF ARTICLES SHOW", str(count))

        ########################################################################
        
    def d_link_text_test(self):
    	    
    	"""
    	This test grabs the link text (text between <a></a> tags) for each link.  
    	Each page is clicked on to ensure that the link works.
    	The title of the opened page is acquired.
    	The title text is compared to the link text to make sure the right page opens.
    	NOTE:  There may be some exceptions to this string matching test - not all links
    	will pass this part.  Most of the articles use the link text as the page's title.  As long
    	as the pages load, this test is considered valid in that respect.  This test will satisfy the
    	requirement that the article headline be displayed for each clickable entry.
    	
    	PASSING CONDITIONS:  Each link has text associated with it
    			     Each link can be clicked on
    			     Each page loads and has a title
    			     The page title matches the link text
    			     
    	FAILING CONDITIONS:  Links have no text for the user to see/click on
    			     Links cannot be clicked on
    			     Pages do not load or have "not found" in the title
    			     The page title does not match the link text
    	
    	
    	"""
    	
        n = 0
	sel = self.selenium
	test = "Test D - Do the Links Open the Right Pages?"
	print test
        
	for each in keys:

	    d = keys[n] 
        
            try:
            	text = sel.get_text("//a[@href='" + d + "']")
            	
            except AssertionError, e:
            	L.log(BROWSERS[x], test, "FAIL, CANNOT GET LINK TEXT", d, exception=str(e))
                print "FAILURE, CAN'T GET LINK TEXT " + d, "Error: " + str(e)
                self.verificationErrors.append(str(e))
                
            # Second, get the title and search the title for the link text
            	
            try:
            	sel.click("//a[@href='" + d + "']")
            	sel.wait_for_page_to_load("50000")
                title = sel.get_title()
                
            except AssertionError, e:
            	L.log(BROWSERS[x], test, "FAIL, CANNOT OPEN PAGE AND GET TITLE", d, exception=str(e))
                print "FAILURE, CAN'T OPEN PAGE AND GET TITLE " + d, "Error: " + str(e)
                self.verificationErrors.append(str(e))
                
            else:
            	L.log(BROWSERS[x], test, "PASS, PAGE OPENS, TITLE ACQUIRED", d)
            	
                if re.search(text, title, re.I):
                    L.log(BROWSERS[x], test, "PASS, CORRECT PAGE LOADS", d)
                        
                elif (re.search("not found", title, re.I) or re.search("500", title)):
                    L.log(BROWSERS[x], test, "FAIL, 404/500 ERROR", d)
                    	
                else:
                    print "Test has a bug / exception, verify:"
                    print "Link: " + d, "Title: " + title, "Text: " + text
                    
                sel.go_back()
                sel.wait_for_page_to_load("50000")
                 
            n += 1   

        ########################################################################    	    
            
    def e_comments_test(self):
    	
    	n - 0
    	for each in keys:
        	
            data = values[n]	
            comments = data[1]
    	
        pass
            
        ########################################################################
        
    def f_entry_type_test(self):
    	
    	n = 0
    	for each in keys:
        	
            data = values[n]	
            entry_type = data[0]
            
        pass
            
        ########################################################################
        
    def g_logo_test(self):
    	    
    	"""
    	This test will make sure that the logo links to the correct page.
    	This test will also verify that the iPhone clickables link is on the page and functional
    	
    	PASSING CONDITIONS:  	Logo image can be clicked on and takes user to right URL
    				The iPhone app image can be clicked on and takes user to right URL
    				
    	FAILING CONDITIONS:	Logo image is not located in 2 places
    				User is not taken to clickables URL
    				iPhone app does not work or does not take user to correct URL
    	
    	"""
    	
    	n = 0
	sel = self.selenium
	test = "Test G - Clickables Logo and iPhone App"
	print test
	
	iphone = ("http://itunes.apple.com/us/app/vulture-clickables/id461132952?mt=8", "http://images.nymag.com/gfx/sect/vulture/clickables-hp-promo.png")
	logo = ("http://www.vulture.com/clickables/", "Vulture Clickables - Viral Videos, Songs, Trailers and TV Clips")	

	# Logo test

	for n in range(1,3):

	    try:
	        sel.click("xpath=(//a[@name='&lpos=Vulture: HomePage: Clickables: Logo'])[" + str(n) + "]")
	        sel.wait_for_page_to_load("50000")
	        title = sel.get_title()
	        
            except AssertionError, e:
            	L.log(BROWSERS[x], test, "FAIL, CANNOT CLICK ON LOGO", logo[0], exception=str(e))
                print "FAILURE, CAN'T CLICK ON LOGO ", "Error: " + str(e)
                self.verificationErrors.append(str(e))
	
	    else:
	    	try:
	    	    self.assertEqual(title, logo[1])
	    	    
	        except Exception, e:
	            L.log(BROWSERS[x], test, "FAIL, TITLES DO NOT MATCH", "Title: " + title + "Logo: " + logo[1], exception=str(e))
                    print "FAILURE, TITLES DO NOT MATCH " + title, "Error: " + str(e)
                    self.verificationErrors.append(str(e))
	    
    		else:
    		    L.log(BROWSERS[x], test, "PASS, TITLE OK", title)
	        
	    n += 1
	    sel.go_back()
	    sel.wait_for_page_to_load("50000")
	    
	# iPhone app page
	    
	try:
	    sel.click("//img[@src='" + iphone[1] + "']")
	    sel.wait_for_page_to_load("50000")
	    self.assertEqual(sel.get_location(), iphone[0])
	    
	except AssertionError, e:
	    L.log(BROWSERS[x], test, "FAIL, CANNOT CLICK ON IMAGE", iphone[1], exception=str(e))
            print "FAILURE, CANNOT CLICK ON IMAGE " + iphone[1], "Error: " + str(e)
            self.verificationErrors.append(str(e))
	
	else:
	    L.log(BROWSERS[x], test, "PASS, IPHONE APP PAGE LOADS", iphone[1])
	
	########################################################################
	
    def tearDown(self):

        self.selenium.stop()
        self.assertEqual([], self.verificationErrors)

#########################################################################
#########################################################################

for each in BROWSERS:

    suite = unittest.TestLoader().loadTestsFromTestCase(Clickables)
    unittest.TextTestRunner(verbosity=2).run(suite)
    x += 1
L.save()
